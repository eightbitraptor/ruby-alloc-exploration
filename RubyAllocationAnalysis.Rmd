---
title: "Ruby Allocation Analysis"
author: "Matt Valentine-House"
date: "07/09/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warnings=FALSE, fig.width = 10, fig.height = 8)

r <- getOption("repos")
r["CRAN"] <- "https://www.stats.bris.ac.uk/R/"
options(repos = r)

if (!requireNamespace('tidyverse'))
  install.packages('tidyverse')

if (!requireNamespace('ggplot2'))
  install.packages('ggplot2')

library(ggplot2)
library(tidyverse)


options(scipen=999, dplyr.summarise.inform = FALSE)

addUnits <- function(n) {
  labels <- ifelse(n < 1000, n,  # less than thousands
                   ifelse(n < 1e6, paste0(round(n/1e3, digits=1), 'k'),  # in thousands
                          ifelse(n < 1e9, paste0(round(n/1e6, digits=1), 'M'),  # in millions
                                 ifelse(n < 1e12, paste0(round(n/1e9, digits=1), 'B'), # in billions
                                        ifelse(n < 1e15, paste0(round(n/1e12, digits=1), 'T'), # in trillions
                                               'too big!')))))
  return(labels)
}

```

## Gathering data for malloc usage in a Ruby program

Using `malloc_history` on macOS we can analyse and record calls to malloc family
functions during execution of a program. This works by setting an environment
variable that instructs the malloc library to log all allocations when your
target program is run.

Once malloc is logging all allocations we can then attach to the target process
and dump the allocation data to a file.

In this example I am dumping all the allocations made during the bootup process
of Shopify core. In order to do this I first had to disable spring, and then
start the application. I started it using `rails/runner` with the command string
`puts Process.pid; $stdin.gets` in order to only boot the application and then
wait.

```{eval=FALSE}
# disable spring
spring stop
./bin/spring binstubs --remove --all

# start the application and wait
MallocStackLoggingNoCompact=1 ./bin/rails runner 'puts Process.pid; $stdin.gets'
```

We use `MallocStackLoggingNoCompact` instead of `MallocStackLogging` to ensure
that the `malloc_history` tool keeps all allocation information, even for small
or short lived allocations.

Next we can use `malloc_history` to read the data and extract the relevant
information to a log file:

```
malloc_history -allBySize <pid> > malloc.log
```

Information about macOS's built in malloc debugging tools can be found in the
[Apple documentation
archive](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html)

## Processing the data for display

The log files that `malloc_history` outputs aren't the most readable. The data
is in the following format

```
1 call for 8192 bytes: 0x7fff71d59cc9 (libdyld.dylib) start | 0x10e04e434 (ruby) main | 0x7fff43f75587 (libruby.2.6.dylib) ruby_init | 0x7fff43f75552 (libruby.2.6.dylib) ruby_setup | 0x7fff43f9323d (libruby.2.6.dylib) rb_call_inits | 0x7fff43f70e50 (libruby.2.6.dylib) Init_Exception | 0x7fff43f34e27 (libruby.2.6.dylib) rb_define_class | 0x7fff44054f0b (libruby.2.6.dylib) rb_intern3 | 0x7fff44056097 (libruby.2.6.dylib) ??? | 0x7fff44055359 (libruby.2.6.dylib) ??? | 0x7fff43f19e2a (libruby.2.6.dylib) rb_ary_tmp_new | 0x7fff43f19b5e (libruby.2.6.dylib) ??? | 0x7fff43f84e3b (libruby.2.6.dylib) ??? | 0x7fff71f0fcf5 (libsystem_malloc.dylib) malloc | 0x7fff71f0fd9e (libsystem_malloc.dylib) malloc_zone_malloc
```

We can use the following Ruby program to parse the raw log data and turn it
into a CSV containing allocations grouped by size, and also containing caller
information for each group

```{ruby, code=xfun::read_utf8('process_malloc.rb'), eval=FALSE, echo = TRUE}
```

Now we can load that data into R

```{r message = FALSE}
allocations <- read_csv('allocation_data.csv')
```

## Exploring the data

In total this code makes `r sum(allocations$count)` calls to malloc. Let's take a look at what functions are calling malloc most frequently

```{r}
sorted_callers <- allocations %>%
  group_by(caller) %>%
  summarise(
    median_bytes = median(bytes_requested),
    mean_bytes = sprintf("%.3f", mean(bytes_requested)),
    min_bytes = min(bytes_requested),
    max_bytes = max(bytes_requested),
    count = n()
  )

sorted_callers
```

Let's exclude some of the results that we know we're not interested in because they're large allocations made as part of the VM initialisation.

```{r}
filtered_allocations <- allocations %>%
  filter(!caller %in% c(
    "Init_TransientHeap",
    "transient_heap_block_alloc",
    "fiber_pool_allocate_memory",
    "fiber_pool_expand",
    "Init_BareVM",
    "dln_load",
    "rb_thread_create_timer_thread"))
```

Let's sort the remaining allocations into bins based on how many RVALUES they
would take up. The first bin will be everything that can be represented by one
RVALUE, ie. < 40 bytes. The next bins will be 10 RVALUES wide, and finally the
last bin will be everything that is a whole Ruby heap page or larger. This will
give us an idea of what our memory allocation will look like in a world where we
are trying to allocate everything on the Ruby GC heap.

- 0-40 bytes: 1 RVALUE
- 41-400 bytes: 2-10 RVALUES
- 401-800 bytes: 11-20 RVALUES
- 801-1200 bytes: 21-30 RVALUES
- ... (skipped for brevity)
- 15601-1600: 390 - 400 RVALUES
- 16001 - 16320: 401 - 408 RVALUES (This is the page boundary)
- 16320+: all these allocations are larger than an entire page of the Ruby GC heap

Let's visualise the total count of allocations in each of the bins

```{r}
bins <- c(-Inf, 40, seq(from = 400, to = 16320, by = 400), 16320, Inf)
labels <- c("<1", sprintf("<%d", seq(from = 10, to = 400, by = 10)), "<408", ">408")

filtered_allocations <- filtered_allocations %>%
  mutate(request_size_bin = cut(bytes_requested, breaks = bins, labels = labels))

grouped_allocations <- filtered_allocations %>%
  group_by(request_size_bin) %>%
  summarise(count = n())

ggplot(grouped_allocations, aes(x = count, y = request_size_bin)) +
  geom_point(size=1) +
  geom_segment(aes(y=request_size_bin, yend=request_size_bin, x=0, xend=count)) +
  geom_text(aes(label=count, x=(max(count)/90 + count)), hjust=0, size=2) +
  labs(title = "Allocation counts binned by RVALUE multiples", y = "Requested allocation size, by RVALUE", x = "quantity") +
  scale_x_continuous(labels = addUnits)
```

## Looking closer at allocations greater than a page length

```{r}
total_large_allocs <- filtered_allocations %>%
  filter(request_size_bin %in% c('>408'))

perc <- count(total_large_allocs) / count(filtered_allocations)
```

We can see that allocations that are larger than 408 RVALUES (ie. 1 heap page) are `r sprintf("%1.2f%%", perc * 100)` of the total number of allocations

```{r}
large_allocations <- total_large_allocs %>%
  group_by(caller)

ggplot(large_allocations, aes(x = bytes_requested, y = reorder(caller, bytes_requested, FUN=median))) +
  geom_boxplot(coef=25) +
  scale_x_continuous(labels = addUnits) +
  theme(axis.text.y = element_text(hjust=0)) + 
  labs(title = "Size of allocations greater than 1 heap page", y = "Caller", x = "Bytes requested, ordered by Median")

```
And the same, but with some of the outlier allocations (ie over 2M bytes) removed

```{r}
small_large_allocations <- large_allocations %>%
  filter(bytes_requested < 5000000)

ggplot(small_large_allocations, aes(x = bytes_requested, y = reorder(caller, bytes_requested, FUN = median))) +
  geom_boxplot(coef=25) +
  scale_x_continuous(labels = addUnits) +
  theme(axis.text.y = element_text(hjust=0)) + 
  labs(title = "Size of allocations greater than 1 heap page", y = "Caller", x = "Bytes requested, ordered by Median")

```

Looking at the source of the most frequent large allocations

```{r}
grouped_large_allocations <- large_allocations %>%
  group_by(caller) %>%
  summarise(count = n())

ggplot(grouped_large_allocations, aes(x = count, y = reorder(caller, count))) +
  geom_bar(stat = "identity") +
    theme(axis.text.y = element_text(hjust=0))
```


## Looking at allocations that are <40 RVALUES

```{r}
total_small_allocs <- filtered_allocations %>%
  filter(request_size_bin %in% c('<30', '<10', '<1'))

perc <- count(total_small_allocs) / count(filtered_allocations)
```

We can see that allocations that are smaller than 40 RVALUES are `r sprintf("%1.2f%%", perc * 100)` of the total number of allocations

```{r fig.height=10}
small_allocations <- total_small_allocs %>%
  group_by(caller) %>%
  select(c('bytes_requested', 'caller'))

ggplot(small_allocations, aes(x = bytes_requested, y = reorder(caller, bytes_requested, FUN = median))) +
  geom_boxplot(coef = 12) +
  scale_x_continuous(labels = addUnits) +
  #scale_y_continuous(breaks=seq(0,1200,40)) +
  theme(axis.text.y = element_text(hjust=0)) + 
  labs(title = "Size of allocations smaller than 30 RVALUES (1200 bytes)", y = "Caller", x = "Bytes requested, ordered by Median")

```

There aren't really many outliers that are worth cutting off in this case, we can see that several functions have reasonable ranges of allocations that take up nearly the whole range between 1 and 40 RVALUES worth. Let's move on to looking at call counts

```{r fig.height = 10}
grouped_small_allocations <- total_small_allocs %>%
  group_by(caller) %>%
  summarise(count = n())

ggplot(grouped_small_allocations, aes(x = count, y = reorder(caller, count))) +
  geom_bar(stat = "identity") +
    theme(axis.text.y = element_text(hjust=0))
```

## Heap page allocate. I am confused to see `heap_page_allocate` in these allocation charts. `heap_page_allocate` allocates memory in 2 places:

```{c eval=FALSE}
    page_body = (struct heap_page_body *)rb_aligned_malloc(HEAP_PAGE_ALIGN, HEAP_PAGE_SIZE);
```

This is when the page body is allocated, and is always `HEAP_PAGE_SIZE` bytes. So this shouldn't vary.

The other places malloc is used is here:

```{c eval=FALSE}
  page = calloc1(sizeof(struct heap_page))
```

As we can see this is also called with a constant size which is the size of the `heap_page` struct.

Let's take a look at just the data pertaining to `heap_page_allocate`

```{r}

heap_page_allocate <- filtered_allocations %>%
  filter(caller == 'heap_page_allocate')

ggplot(heap_page_allocate, aes(x = request_size_bin)) + 
  geom_bar()
```

## R Versions and libraries used

```{r}
sessionInfo()
```